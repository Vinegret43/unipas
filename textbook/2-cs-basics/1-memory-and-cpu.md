# Память и процессор компьютера

## Что вообще такое эта "оперативная память"?
Представь себе архивный шкаф со множеством ящиков. Ящики последовательно пронумерованы,
номер каждого из них уникален. В каждом ящике лежит бумага, на которой написано число от
0 до 255. В дальнейшем будем называть такое число *байтом*. Зная номер ящика, можно открыть
его и посмотреть, какое число хранится внутри, либо стереть это число и записать новое.
Номер ящика также будем называть его *адресом*.

![Архивный шкаф](/artwork/cs-101/archive-cabinet.png)

Правда, в современные компьютеры, как правило, ставят 16 гигабайт памяти, что равняется
16,777,216 байтам, поэтому данный шкаф скорее выглядел бы примерно так:

![Гигантский архивный шкаф](/artwork/cs-101/giant-archive-cabinet.png)

К счастью, в оперативной памяти компьютера эти числа хранятся не на бумажках, а в виде
электрических зарядов на кремниевом кристалле. Получается крайне компактно, да ещё
и чтение/запись информации происходят невероятно быстро.

![Плашка оперативной памяти](/artwork/cs-101/ram-stick.png)

Только не думайте, что в шкафе невозможно хранить числа, большие 255. Отдельный
ящик хранит числа от 0 до 255, следовательно, он может находиться в 256 отличных
друг от друга состояниях. А если взять два ящика, то они, как единая система,
могут находиться в 256*256=65,536 различных состояниях. Поэтому с помощью
двух ящиков можно закодировать, например, число от 1 до 65,536. Или от 0 до
65,535 (зачастую используется именно такой вариант). Всё зависит от того, как
сам пользователь шкафа интерпретирует информацию, находящуюся в нём.

## А что такое процессор?
Обычный шкаф, хранящий кучу чисел, полностью бесполезен. Он ведь только хранит
числа, а использовать их никак не может. К счастью, у нас в распоряжении есть
офисный работник по имени Боб, который может работать с этим шкафом, а также
делать ещё целую кучу вещей. К примеру, запоминать небольшое количество чисел
и производить с ними математические операции. Или работать с устройствами ввода/вывода,
к которым относятся жёсткие диски, SSD и другие постоянные носители информации,
мыши, клавиатуры, видеокарты, сетевые интерфейсы и прочее.

![Боб](/artwork/cs-101/bob.png)

Сам по себе Боб не знает, что ему надо делать: в собственной памяти он может хранить
совсем немного информации, инструкции по работе там не помещаются. Поэтому все инструкции
хранятся в шкафу. Для обычного человека они выглядят всего лишь как наборы
бессмысленных чисел. А вот Боб с самого детства готовился к своей работе, поэтому он
отлично знает смысл каждой инструкции. Открывает ящик, видит там число и сразу понимает,
что ему надо делать.

Благодаря тому, что инструкции хранятся прямо в шкафу, Бобу не нужно запоминать их,
достаточно запомнить только номер ящика, в котором хранится следующая инструкция,
которую надо выполнить. Этот самый номер называется *курсором*, потому что он указывает
на следующую инструкцию.

В памяти инструкции хранятся последовательно, одна за другой. Разные инструкции могут занимать
разное число байтов, однако Боб знает длину каждой инструкции. Поэтому, чтобы
получить адрес следующей инструкции, Боб просто увеличивает значение курсора на
число, равное длине текущей инструкции в байтах. Адрес инструкции - это адрес
её *первого* байта.

По умолчанию Боб выполняет все инструкции в последовательном порядке, однако могут
быть и исключения. К примеру, есть инструкция, которую люди обычно обозначают как `jmp`
(от слова "jump"). Эта самая инструкция говорит Бобу, что надо "перепрыгнуть" в другую часть
памяти и начать выполнять инструкции там. По сути, она просто присваивает курсору какое-то
произвольное значение.

Понятное дело, что на самом деле Боб - не человек, а кремниевый чип, заключённый между
печатной платой и металлической крышкой. Вот так поворот сюжета, сам Голливуд позавидует.

![Разобранный процессор](/artwork/cs-101/cpu-dissection.png)

## Как обмануть Боба
Любопытный факт: получается, что в оперативной памяти компьютера одновременно хранятся
и сами программы (последовательности инструкций для Боба), и данные, с которыми
они работают. С одной стороны, это удобно. А с другой стороны, создаёт определённые
риски. Допустим, есть программа, которая скачивает картинки котиков с удалённого
сервера в Интернете и сохраняет их в оперативную память. Что произойдёт, если сервер вместо
картинки котика передаст набор вредоносных инструкций для Боба? Казалось бы, ничего
страшного, эти инструкции просто запишутся в память и будут там лежать без дела.

На самом деле это не совсем так: существует древнее магическое искусство, включающее в себя
заклинания, называемые "переполнение буфера" и "перезапись адреса возврата". Они
позволяют обмануть Боба и заставить его выполнять вредоносные инструкции,
находящиеся в произвольной области оперативной памяти. Чтобы применить эти техники,
необходимо эксплуатировать ошибки в программах, которые программисты оставляют
по невнимательности. Сейчас мы в это углубляться особо не будем, так как тема довольно
сложная, но одну вещь на будущее я всё-таки скажу. Обязательно изучите эту тему,
если захотите начать прогать на C, C++ или подобных им языкам, в которых можно
напрямую работать с памятью компьютера. Потому что иначе вы гарантированно выстрелите себе в ногу.

<img class="universal" src="/artwork/cs-101/cat.jpg" alt='Картинка с котиком, поверх которой написано: "это не картинка котика, вас только что взломали"'/>

(На самом деле вас не взломали, всё нормально. На сегодняшний день веб-браузеры хорошо
защищены от подобного рода атак. Да и картинка эта абсолютно обычная)
